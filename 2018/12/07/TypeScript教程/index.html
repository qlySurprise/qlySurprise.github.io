
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>好嗨哦</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="在做移动端的时候，经常碰到在触发软键盘的时候导致页面压缩或者是输入框被遮挡了。以下为解决方式：
var clientHeight = document.body.clientHeight;    v,"> 
    <meta name="author" content="qly"> 
    <link rel="alternative" href="atom.xml" title="好嗨哦" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">TypeScript教程 </h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">TypeScript教程 </h1>
        <div class="stuff">
            <span>十二月 07, 2018</span>
            

        </div>
        <div class="content markdown">
            <p>##第01节：初识TypeScript<br>TypeScript是什么？</p>
<p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，TypeScript 在 JavaScript 的基础上添加了可选的静态类型和基于类的面向对象编程。</p>
<p>其实TypeScript就是相当于JavaScript的增强版，但是最后运行时还要编译成JavaScript。TypeScript最大的目的是让程序员更具创造性，提高生产力，它将极大增强JavaScript编写应用的开发和调试环节，让JavaScript能够方便用于编写大型应用和进行多人协作。</p>
<h3 id="TypeScript和JavaScript的对比"><a href="#TypeScript和JavaScript的对比" class="headerlink" title="TypeScript和JavaScript的对比"></a>TypeScript和JavaScript的对比</h3><p>TypeScript 与JavaScript两者的特性对比，主要表现为以下几点：</p>
<p>TypeScript是一个应用程序级的JavaScript开发语言。（这也表示TypeScript比较牛逼，可以开发大型应用，或者说更适合开发大型应用）<br>TypeScript是JavaScript的超集，可以编译成纯JavaScript。这个和我们CSS离的Less或者Sass是很像的，我们用更好的代码编写方式来进行编写，最后还是有好生成原生的JavaScript语言。<br>TypeScript跨浏览器、跨操作系统、跨主机、且开源。由于最后他编译成了JavaScript所以只要能运行JS的地方，都可以运行我们写的程序，设置在node.js里。<br>遵循JavaScript的语法和语义。<br>TypeScript可以重用JavaScript代码，调用流行的JavaScript库。<br>TypeScript提供了类、模块和接口，更易于构建组件和维护。</p>
<p>##第02节：开发环境的安装</p>
<h3 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h3><p>安装Node.js非常简单，只要到Node官网下载一个最新版本就可以了：<a href="https://nodejs.org/zh-cn/.在windows上的安装方法和安装QQ一样。我这里就不重复描述了。" target="_blank" rel="noopener">https://nodejs.org/zh-cn/.在windows上的安装方法和安装QQ一样。我这里就不重复描述了。</a> 安装好后，可以打开命令行工具，同时按下win+R，然后输入cmd就可以打开，打开后输入</p>
<p>node -v<br>npm -v<br>如果看到版本号说明已经安装成功了，看不到版本号就说明你的node.js没有安装成功。</p>
<h3 id="2-安装TypeScript包"><a href="#2-安装TypeScript包" class="headerlink" title="2.安装TypeScript包"></a>2.安装TypeScript包</h3><p>在刚才的命令行窗口继续输入如下命令：</p>
<p>npm install typescript -g<br>tsc –version<br>需要注意的是：如果你是mac电脑，要使用sudo npm install typescript -g指令进行安装</p>
<h3 id="3-编写HelloWorld程序"><a href="#3-编写HelloWorld程序" class="headerlink" title="3.编写HelloWorld程序"></a>3.编写HelloWorld程序</h3><p>初始化项目：进入你的编程文件夹后，可以使用npm init -y来初始化项目，生成package.json文件。</p>
<p>创建tsconfig.json文件，在终端中输入tsc –init：它是一个TypeScript项目的配置文件，可以通过读取它来设置TypeScript编译器的编译参数。</p>
<p>安装@types/node,使用npm install @types/node –dev-save进行安装。这个主要是解决模块的声明文件问题。</p>
<p>编写HelloWorld.ts文件，然后进行保存，代码如下。</p>
<p>var a:string = “HelloWorld”<br>console.log(a)<br>在Vscode的任务菜单下，打开运行生成任务，然后选择tsc：构建-tsconfig.json，这时候就会生成一个helloWorld.js文件</p>
<p>在终端中输入node helloWorld.js就可以看到结果了。</p>
<p>##第03节：变量类型的那些事</p>
<p>TypeScript中的数据类型有：</p>
<p>Undefined :<br>Number:数值类型;<br>string : 字符串类型;<br>Boolean: 布尔类型；<br>enum：枚举类型；<br>any : 任意类型，一个牛X的类型；<br>void：空类型；<br>Array : 数组类型;<br>Tuple : 元祖类型；<br>Null ：空类型。<br>Undefined类型<br>在js中当你定义了一个变量，但没有给他赋予任何值的时候，他就是Undefined类型。这可能和你以前学的语言稍有不同，其他语言会有个类型的默认值。</p>
<p>我们现在来看一个例子，比如我们要声明一个年龄的变量age,我们要使用数值类型，也就是Number,但是我们不给他任何的值，我们只是在控制台给它输出，然后我们来看结果。</p>
<p>新建demo01.ts文件，下入下面代码：</p>
<p>//声明数值类型的变量age，但不予赋值<br>var age:number<br>console.log(age)<br>写完后保存代码，进行运行任务，然后生成demo01.js，在终端中使用node demo01.js来进行查看运行结果。控制台输出了undefined,跟我们预想的一模一样。</p>
<p>Number类型<br>在TypeScript中，所有的数字都是Number类型，这不分是整数还是小数。比如下面我们声明一个年龄是18岁，身高是178.5厘米。</p>
<p>新建一个文件demo01_1.ts文件，写入下面代码：</p>
<p>var age:number = 18<br>var stature:number = 178.5<br>console.log(age)<br>console.log(stature)<br>然后执行转换，查看结果，我们可以在控制台看到结果已经顺利输出，没有任何意外。</p>
<p>在TypeScrip中有几种特殊的Number类型 我们需要额外注意一下：</p>
<p>NaN：它是Not a Number 的简写，意思就是不是一个数值。如果一个计算结果或者函数的返回值本应该是数值，但是由于种种原因，他不是数字。出现这种状况不会报错，而是把它的结果看成了NaN。（这就好比我们去泰国外，找了一个大长腿、瓜子脸、水蛇腰的女神。房也开好了，澡也洗完了，发现跟我们的性别统一，我们只能吃个哑巴亏，你绝不会声张）<br>Infinity :正无穷大。<br>-Infinity：负无穷大。<br>string类型<br>由单引号或者双引号括起来的一串字符就是字符串。比如：“你好啊”,’opq.com’。看下面的代码：</p>
<p>demo01_2.ts</p>
<p>var opq:string = “你好啊 opq.com”<br>console.log(opq)<br>这时候控制图就会乖乖的输出你好啊 opq.com.</p>
<p>boolean布尔类型<br>作任何业务逻辑判断都要有布尔类型的参与，通过对与错的判断是最直观的逻辑处理。boolean类型只有两种值，true和false。</p>
<p>var b:boolean = true<br>var c:boolean = false<br>enum 类型<br>这个世界有很多值是多个并且是固定的，比如：</p>
<p>世界上人的类型：男人、女人、中性<br>一年的季节：春、夏、秋、冬 ，有四个结果。<br>这种变量的结果是固定的几个数据时，就是我们使用枚举类型的最好时机：</p>
<p>demo01_3.ts</p>
<p>enum REN{ nan , nv ,yao}<br>console.log(REN.yao)  //返回了2，这是索引index，跟数组很想。<br>如果我们想给这些枚举赋值，可以直接使用=,来进行赋值。</p>
<p>enum REN{<br>    nan = ‘男’,<br>    nv = ‘女’,<br>    yao= ‘妖’<br>}<br>console.log(REN.yao)  //返回了妖 这个字<br>any类型<br>一个写惯了前端的人，有时候不自觉的就分不清类型了。这是个不好的习惯，也是前端的痛，就因为这个原因，JavaScript也多次被人诟病说大型项目不适合用JavaScript。但是习惯一旦养成，改是需要时间和磨练的。TypeScript友好的为我们提供了一种特殊的类型any，比如我们在程序中不断变化着类型，又不想让程序报错，这时候就可以使用any了。</p>
<p>var t:any =10<br>t = “opq”<br>t = true<br>console.log(t)<br>Null类型：</p>
<p>与 Undefined 类似，都代表空。Null 代表是引用类型为空。意义不大，但是有用。</p>
<h2 id="第04节：TypeScript的函数"><a href="#第04节：TypeScript的函数" class="headerlink" title="第04节：TypeScript的函数"></a>第04节：TypeScript的函数</h2><p>现在我们有个找小姐姐的需求：</p>
<p>找18岁的小姐姐<br>找28岁的小姐姐<br>找38岁的小姐姐</p>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>函数就相当于一个工具，如果你想使用这个工具，就要先制作这个工具。这就是我们说的定义函数。在TypeScript里定义函数跟JavaScript稍微有些不同。我们来定义找小姐姐的函数吧。</p>
<p>function searchXiaoJieJie(age:number):string{<br>    return ‘找到了’+age+’岁的小姐姐’<br>}<br>var age:number = 18<br>var result:string = searchXiaoJieJie(age)<br>console.log(result)<br>上面的程序，先用function关键字声明了一个searchXiaoJieJie的方法，然后我们使用了他，并返回了给我们结果。</p>
<p>需要注意的是：</p>
<p>声明（定义）函数必须加 function 关键字；<br>函数名与变量名一样，命名规则按照标识符规则；<br>函数参数可有可无，多个参数之间用逗号隔开；<br>每个参数参数由名字与类型组成，之间用分号隔开；<br>函数的返回值可有可无，没有时，返回类型为 void；<br>大括号中是函数体。</p>
<h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><h4 id="形参的使用"><a href="#形参的使用" class="headerlink" title="形参的使用"></a>形参的使用</h4><p>函数定义的时候写的参数是形参。从字面意义上我们可以看出，形参就是形式上的参数。我们定义了形参也就规定了此函数的参数个数和参数类型，规范了函数。</p>
<p>function searchXiaoJieJie(age:number):string{<br>    return ‘找到了’+age+’岁的小姐姐’<br>}<br>比如这个函数，就定义了一个形参，它的类型是数值类型。</p>
<p>实参的使用</p>
<p>调用函数时传递的具体值就是实参。同样从字面理解，实参就是真实的参数，我们在使用的时候，具体真实传递过去的就是实参，比如18，20，22，这些具体的参数就是实参。</p>
<p>打个比方，我们去按摩，需要找技师，当我们还没有找的时候，这时候就是形参。当一个个技师站好了，让你选。你最终选择了一个，这就是实参。实参在真实使用时才传递。</p>
<p>var result:string = searchXiaoJieJie(age)<br>注意</p>
<p>在函数调用的时候，我们需要按照形参的规则传递实参，有几个形参就要传递几个实参，并且每一个实参的类型要与对应的形参类型一致。</p>
<h3 id="TypeScript语言中的函数参数"><a href="#TypeScript语言中的函数参数" class="headerlink" title="TypeScript语言中的函数参数"></a>TypeScript语言中的函数参数</h3><p>TypeScript的函数参数是比较灵活的，它不像那些早起出现的传统语言那么死板。在TypeScript语言中，函数的形参分为：可选形参、默认形参、剩余参数形参等。</p>
<h4 id="1-有可选参数的函数"><a href="#1-有可选参数的函数" class="headerlink" title="1.有可选参数的函数"></a>1.有可选参数的函数</h4><p>可选参数，就是我们定义形参的时候，可以定义一个可传可不传的参数。这种参数，在定义函数的时候通过?标注。</p>
<p>比如我们继续作找小姐姐的函数，这回不仅可以传递年龄，还可以选择性的传递身材。我们来看如何编写。</p>
<p>function searchXiaoJieJie2(age:number,stature?:string):string{<br>    let yy:string = ‘’<br>    yy = ‘找到了’+age+’岁’<br>    if(stature !=undefined){<br>        yy = yy + stature<br>    }<br>    return yy+’的小姐姐’<br>}<br>var result:string  =  searchXiaoJieJie2(22,’大长腿’)<br>console.log(result)</p>
<h4 id="2-有默认参数的函数"><a href="#2-有默认参数的函数" class="headerlink" title="2.有默认参数的函数"></a>2.有默认参数的函数</h4><p>有默认参数就更好理解了，就是我们不传递的时候，他会给我们一个默认值，而不是undefined了。我们改造上边的函数，也是两个参数，但是我们把年龄和身材都设置默认值，这就相当于熟客，我们直接来一句照旧是一样的。</p>
<p>function searchXiaoJieJie2(age:number=18,stature:string=’大胸’):string{<br>    let yy:string = ‘’<br>    yy = ‘找到了’+age+’岁’<br>    if(stature !=undefined){<br>        yy = yy + stature<br>    }<br>    return yy+’的小姐姐’<br>}<br>var result:string  =  searchXiaoJieJie2()<br>console.log(result)</p>
<h4 id="3-有剩余参数的函数"><a href="#3-有剩余参数的函数" class="headerlink" title="3.有剩余参数的函数"></a>3.有剩余参数的函数</h4><p>有时候我们有这样的需求，我传递给函数的参数个数不确定。例如：我找小姐姐的时候有很多要求，个人眼光比较挑剔。这时候你不能限制我，我要随心所欲。</p>
<p>说的技术点，剩余参数就是形参是一个数组，传递几个实参过来都可以直接存在形参的数组中。</p>
<p>function searchXiaoJieJie3(…xuqiu:string[]):string{<br>    let  yy:string = ‘找到了’<br>    for (let i =0;i&lt;xuqiu.length;i++){<br>        yy = yy + xuqiu[i]<br>        if(i&lt;xuqiu.length){<br>            yy=yy+’、’<br>        }<br>    }<br>    yy=yy+’的小姐姐’<br>    return yy<br>}<br>var result:string  =  searchXiaoJieJie3(‘22岁’,’大长腿’,’瓜子脸’,’水蛇腰’)<br>console.log(result)</p>
<h2 id="第05节：三种函数的定义方式"><a href="#第05节：三种函数的定义方式" class="headerlink" title="第05节：三种函数的定义方式"></a>第05节：三种函数的定义方式</h2><h3 id="函数声明法"><a href="#函数声明法" class="headerlink" title="函数声明法"></a>函数声明法</h3><p>函数声明法创建函数是最常用的函数定义法。使用function关键字和函数名去定义一个函数。</p>
<p>function add(n1:number,n2:number):number{<br>    return n1+n2<br>}</p>
<h3 id="函数表达式法"><a href="#函数表达式法" class="headerlink" title="函数表达式法"></a>函数表达式法</h3><p>函数表达式法是将一个函数赋值给一个变量，这个变量名就是函数名。通过变量名就可以调用函数了。这种方式定义的函数，必须在定义之后，调用函数。下面例子中等号右边的函数没有函数名，称为匿名函数。</p>
<p>var add = function(n1:number,n2:number):number{<br>    return n1+n2<br>}<br>console.log(add(1,4))</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数是 ES6 中新增的函数定义的新方式，我们的 TypeScript 语言是完全支持 ES6 语法的。箭头函数定义的函数一般都用于回调函数中。</p>
<p>var add = (n1:number,n2:number):number=&gt;{<br>    return n1+n2<br>}<br>console.log(add(1,4))</p>
<h2 id="第06节：函数中变量的作用域"><a href="#第06节：函数中变量的作用域" class="headerlink" title="第06节：函数中变量的作用域"></a>第06节：函数中变量的作用域</h2><p>通过两节对TypeScript的学习，再加上如果你以前JavaScript的知识很扎实，你一定知道函数类似于一个封闭的盒子。盒子里面的世界和外面的世界是不一样的。有点像人的外在表现和内在性格，虽然相辅相成，相生相克，但是完全不一样。定义在函数内部的变量与定义在函数外部的变量也是不一样的，他们起作用的范围也不一样。</p>
<p>每个变量都有一个起作用的范围，这个范围就是变量的作用域。在TypeScript语言中变量作用域划分是以函数为标准的。</p>
<h3 id="函数作用域演示"><a href="#函数作用域演示" class="headerlink" title="函数作用域演示"></a>函数作用域演示</h3><p>我们来举个例子，现在要制作一个整形的方法，然后在函数里用var定义一个yangzi的变量,我们再函数的外部读取这个变量，你会发现是读取不到的。</p>
<p>function zhengXing():void{<br>    var yangzi = ‘刘德华’<br>    console.log(yangzi)<br>}<br>zhengXing()<br>console.log(yangzi)</p>
<h3 id="认识全局变量和局部变量"><a href="#认识全局变量和局部变量" class="headerlink" title="认识全局变量和局部变量"></a>认识全局变量和局部变量</h3><p>现在我们对函数的作用域有了一点了解，那么到底什么是全局变量，什么又是局部变量那？这个问题很多面试中都会提问，所以跟你的前途息息相关。</p>
<p>局部变量：函数体内定义的变量就是局部变量。<br>全局变量: 函数体外 定义的变量就是全局变量。<br>我们改造上边的程序，把yangzi办理移动到全局，然后再进行输出。</p>
<p>var yangzi = ‘刘德华’<br>function zhengXing():void{<br>    console.log(‘你好啊整形成了’+yangzi+’的样子’)<br>}<br>zhengXing()<br>console.log(yangzi)<br>这时候yangzi变量是全局的，所以在函数内也可以调用，在函数外也可以调用。</p>
<h3 id="局部变量和全局变量重名"><a href="#局部变量和全局变量重名" class="headerlink" title="局部变量和全局变量重名"></a>局部变量和全局变量重名</h3><p>当局部变量与全局变量重名的时候，在函数体内是局部变量起作用；如果重名，就有变量提升，这是一个坑，小伙伴们必须要注意</p>
<p>还是上边整形的例子，你好啊是想整形成刘德华，但是函数体内部声明了一个马德华。虽然一字之差，但是样子可是完全不同的。我们来看代码如何实现：</p>
<p>var yangzi:string = ‘刘德华’<br>function zhengXing():void{<br>    var yangzi:string = ‘马德华’<br>    console.log(‘你好啊整形成了’+yangzi+’的样子’)<br>}<br>zhengXing()<br>console.log(yangzi)<br>这回你会发现，你好啊并没有变成刘德华而是变成了马德华。那你说我我想变成刘德华，我在函数没声明新变量前打印到控制台行不行？</p>
<p>var yangzi:string = ‘刘德华’<br>function zhengXing():void{<br>    console.log(‘你好啊整形成了’+yangzi+’的样子’)<br>    var yangzi:string = ‘马德华’<br>    console.log(‘你好啊整形成了’+yangzi+’的样子’)<br>}<br>zhengXing()<br>console.log(yangzi)<br>代码改造成了这样，但是你会发现，我们输出的结果如下：</p>
<p>你好啊整形成了undefined的样子<br>产生这个结果的原因就是变量提升，他的真实代码是这样的。</p>
<p>var yangzi:string = ‘刘德华’<br>function zhengXing():void{<br>    var  yangzi:string<br>    console.log(‘你好啊整形成了’+yangzi+’的样子’)<br>    yangzi = ‘马德华’<br>    console.log(‘你好啊整形成了’+yangzi+’的样子’)<br>}<br>zhengXing()<br>console.log(yangzi)<br>也就是当内部声明了和全局的变量同名时，就会出现变量提升的效果，声明语句会提升到函数的第一句。这就是著名的变量提升效果。</p>
<h3 id="let关键字变量的作用域"><a href="#let关键字变量的作用域" class="headerlink" title="let关键字变量的作用域"></a>let关键字变量的作用域</h3><p>在早期javascript的变量作用域只有全局和局部，并且是以函数划分的，但在其他语言中，作用域的划分是以一对大括号作为界限的。</p>
<p>所以，JavaScript就遭到了无数开发者的吐槽，甚至说javascript不适合开发大型语言，容易内存溢出。JavaScript团队意识到了这一点，在ES6中推出了let关键字。</p>
<p>使用let关键字的变量就是一个块级作用域变量。希望大家在实际工作中多使用let来声明你的变量，让你的程序更有条例。 来看一端程序：</p>
<p>function zhengXing():void{<br>   var yangzia:string = ‘刘德华’<br>   {<br>        let  yangzib:string = ‘小沈阳’<br>        console.log(‘你好啊整形成了’+yangzib+’的样子’)<br>   }<br>    console.log(‘你好啊整形成了’+yangzia+’的样子’)<br>    console.log(‘你好啊整形成了’+yangzib+’的样子’)<br>}<br>zhengXing()<br>这时候编译后，我们运行，你会发现是可以执行的，并且打印到了控制台正确的结果。 这是因为ts编译成js，他自动给我们加了ES5的处理，ES5里是没有let关键字的，现在我们再改一下编译好的程序，你会发现yangzib这个关键字就找不到了（详情看视频吧）。</p>
<h2 id="第07节-引用类型-数组"><a href="#第07节-引用类型-数组" class="headerlink" title="第07节:引用类型-数组"></a>第07节:引用类型-数组</h2><p>TypeScript中的数据分为值类型和引用类型。值类型我们前几节课讲的都是，但是引用类型我们在这套视频中还没有讲解。我们先来看一个引用类型的例子，来个初步印象。</p>
<h3 id="初识引用类型"><a href="#初识引用类型" class="headerlink" title="初识引用类型"></a>初识引用类型</h3><p>现在把“你好啊”虚拟成一个对象，然后来使用过它，具体看下面的代码：</p>
<p>let opq = {<br>    name:’你好啊’,<br>    website:’opq.com’,<br>    age:18,<br>    saySometing:function(){<br>        console.log(‘为了前端技术’)<br>    }<br>}<br>console.log(opq.name)<br>opq.saySometing()<br>通过上面的案例，我们看到引用类型是一种复合的数据类型，引用类型中封装了很多对属性，每一对属性都有属性名和属性值。属性名是字符串，属性值是任意类型的数据。可以通过变量名和属性名获取属性的值或者调用属性的方法。</p>
<p>在TypeScript中也给我们提供了一些引用类型，例如：Array（数组）、String（字符串）、Date（日期对象）、RegExp（正则表达式）等。我们将用几节课的时间来学习这些用用类型，以及其中封装的常用方法和属性。</p>
<h3 id="初始化数组的两种方法"><a href="#初始化数组的两种方法" class="headerlink" title="初始化数组的两种方法"></a>初始化数组的两种方法</h3><p>你学习这个课程一定对js中的数组有所了解，要使用一个数组，首先要学会创建一个数组。创建数组时可以指定数组的容量，也可以直接向数组中存储数据。</p>
<h4 id="声明数组的方法"><a href="#声明数组的方法" class="headerlink" title="声明数组的方法"></a>声明数组的方法</h4><p>声明数组跟声明一个普通变量是一样的，都是通过 var let 关键字实现的，只不过数组的类型说明符比较复杂而已。</p>
<p>let arr1:number[ ]     //声明一个数值类型的数组<br>let arr2:Array<string>  //声明一个字符串类型的数组</string></p>
<h4 id="给数组赋值"><a href="#给数组赋值" class="headerlink" title="给数组赋值"></a>给数组赋值</h4><p>数组是存储大量数据的集合，声明数组之后，需要给数组存储数据。这时候有两种方法：</p>
<p>字面量赋值法：直接使用“[ ]”对数组进行赋值。<br>构造函数赋值法：</p>
<h4 id="字面量赋值法"><a href="#字面量赋值法" class="headerlink" title="字面量赋值法"></a>字面量赋值法</h4><p>//定义一个空数组，数组容量为0<br>let arr1:number[] = []<br>//定义一个数组时，直接给数组赋值<br>let arr2:number[] = [1,2,3,4,5]<br>//定义数组 的同事给数组赋值<br>let arr3:Array<string> = [‘opq’,’你好啊’,’金三胖’]<br>let arr4:Array<boolean> = [ true,false,false]<br>需要注意的是，在TypeScript中指定数据类型的数组只能存储同一类型的数组元素。</boolean></string></p>
<p>//报错！ 必须存储number类型的数据<br>let arr5:number[] = [1,2,true]</p>
<h4 id="构造函数赋值法"><a href="#构造函数赋值法" class="headerlink" title="构造函数赋值法"></a>构造函数赋值法</h4><p>在 TypeScript 中使用 Array 这个引用类型来表示数组的，那么每一个数组都是 Array 类型的实例。那么，我们在创建数组的时候也可以使用构造函数来进行赋值。</p>
<p>let arr1:number[] = new Array()<br>let ara2:number[] = new Array(1,2,3,4,5)<br>let arr3:Array<string> = new Array(‘opq’,’你好啊’,’金三胖’)<br>let arr4:Array<boolean> = new Array(true,false,false)<br>这两种方法，都可以给数组进行赋值，在实际开发中使用哪种方法都是可以的。</boolean></string></p>
<h3 id="认识元祖，一种特殊的数组"><a href="#认识元祖，一种特殊的数组" class="headerlink" title="认识元祖，一种特殊的数组"></a>认识元祖，一种特殊的数组</h3><p>元祖是一种特殊的数组，元祖类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为string和number类型的元祖。元祖在实际开发中使用的非常少，大家了解一下就可以了，不做过多介绍。</p>
<p>//声明一个元祖类型<br>let x : [string,number]<br>//正确的初始化<br>x = [‘hello’,10]<br>//错误的初始化方法<br>x = [10,’hello’]<br>TypeScript中其它的数组知识跟JavaScript中的一样</p>
<h2 id="第08节-引用类型-字符串"><a href="#第08节-引用类型-字符串" class="headerlink" title="第08节:引用类型-字符串"></a>第08节:引用类型-字符串</h2><p>通过上节学习对引用类型有了一个很好的认识。在TypeScript中存在两种类型的字符串：基本类型字符串和引用类型字符串。\</p>
<h3 id="字符串的两种类型"><a href="#字符串的两种类型" class="headerlink" title="字符串的两种类型"></a>字符串的两种类型</h3><p>基本类型字符串：由单引号或者双引号括起来的一串字符串。<br>引用类型字符串：用new 实例化的 String类型。<br>那为什么会出现这种情况那，有的小伙伴会认为是不是当时JavaScript的开发人员脑子进水了。其实不是的，在前端开发，操作字符串是最普遍的一种操作。JavaScript的开发人员为了大家更容易的操作字符串，有了引用类型的字符串就可以给字符串增加一系列方法了。</p>
<p>let opq:string = ‘你好啊’<br>let opqa:String = new String(“opq.com”)<br>console.log(opq)<br>console.log(opqa)</p>
<p>编译以后我们使用node 运行这段代码，你可以看到控制台输出了的结果，这可能跟你心里想的不太一样。<br>你好啊<br>[String: ‘opq.com’]<br>需要说明的是这两种声明字符串的方法没有什么不同。基本类型的字符串可以直接使用引用类型的属性和方法。</p>
<h3 id="字符串的长度length"><a href="#字符串的长度length" class="headerlink" title="字符串的长度length"></a>字符串的长度length</h3><p>使用length就可以来获取字符串的长度，当然作为一个男人知道自己的长度是非常有必要的…..不好意思，我又开始污了。那我们来看看下面获取长度的列子。</p>
<p>let opq:string = ‘你好啊’<br>let opqa:String = new String(“opq.com”)<br>console.log(opq.length)<br>console.log(opqa.length)</p>
<h3 id="字符串常用的方法"><a href="#字符串常用的方法" class="headerlink" title="字符串常用的方法"></a>字符串常用的方法</h3><p>为了一些刚刚接触前端的小伙伴，我还是讲解一下字符串的常用方法，如果你已经有了很好的JS的基础，下面的内容可以完全跳过的。</p>
<h4 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h4><p>从头部查找字符串直接使用indexOf就可以了。</p>
<p>基本语法：str.indexOf(subStr)</p>
<p>我们来一个找小姐姐的例子：现在我们写一段话，这段话当然是一个字符串，比如：“清早起来打开窗，心情美美的，我要出去找小姐姐，心情美美的。”然后找出“小姐姐”的位置。</p>
<p>let something:string = “清早起来打开窗，心情美美的，我要出去找小姐姐，心情美美的。”<br>let xiaoJieJie:string = “小姐姐”<br>console.log(something.indexOf(xiaoJieJie))   //19<br>如果我们查找的字符串没有找到，则返回-1。</p>
<p>从字符串尾部开始查找字符串的位置，使用lastIndexOf( )</p>
<p>let something:string = “清早起来打开窗，心情美美的，我要出去找小姐姐，心情美美的。”<br>let xiaoJieJie:string = “小姐姐”<br>console.log(something.lastIndexOf(xiaoJieJie)) //19<br>需要注意的是，返回的都是字符串的下标。所以返回的值是相同的。并不是返回从后到前的下标位置。这个新手很容易采坑。</p>
<h4 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h4><p>基本语法如下：</p>
<p>str.substring(startIndex,[endIndex])<br>参数 startIndex 表示开始下标，endIndex 表示结束下标，endIndex 参数是可选的。该方法的作用是从指定的开始下标开始截取字符串，截取到 endIndex 的下标之前，如果没有 endIndex，则截取到字符串结束。</p>
<p>我们还是上面的例子，现在我们截取不同的字符串。</p>
<p>let something:string = “清早起来打开窗，心情美美的，我要出去找小姐姐，心情美美的。”<br>let xiaoJieJie:string = “小姐姐”<br>console.log(something.substring(8))<br>console.log(something.substring(8,14))</p>
<h4 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h4><p>基本语法如下：</p>
<p>str.replace(subStr,newstr);<br>substr 表示被替换的子串，newstr 表示要替换成的子串。该方法的作用是在 str 中从头部开始找 substr 子串，找到之后，把 substr 用 newstr 替换掉。需要注意的是如果 str 中有多个 substr 子串，只有第一个 substr 子串会被替换掉。</p>
<p>现在我们要把上面字符串里的小姐姐替换成小哥哥，我们看看具体代码的实现。</p>
<p>let something:string = “清早起来打开窗，心情美美的，我要出去找小姐姐，心情美美的。”<br>let xiaoJieJie:string = “小姐姐”<br>console.log(something.replace(xiaoJieJie,’小哥哥’))</p>
<h2 id="第09节-引用类型-日期对象"><a href="#第09节-引用类型-日期对象" class="headerlink" title="第09节:引用类型-日期对象"></a>第09节:引用类型-日期对象</h2><p>TypeScript中使用Date这个引用类型来存储日期对象，如果你要声明一个日期变量时，记得也要注明它的类型是Date。<br>创建日期对象</p>
<p>日期对象是Date的实例，可以使用构造函数的方法进行创建。并且构造函数中可以传递多种类型的参数。</p>
<h3 id="1-不传递任何参数"><a href="#1-不传递任何参数" class="headerlink" title="1.不传递任何参数"></a>1.不传递任何参数</h3><p>构造函数中不传递参数时，Date（）构造函数将根据当前日期和时间创建一个Date对象。我们看下面的例子理解一下。</p>
<p>let d:Date = new Date()<br>console.log(d)<br>这时候运行node的结果如下：</p>
<p>2018-09-06T06:48:12.504Z</p>
<h3 id="2-传递一个整数"><a href="#2-传递一个整数" class="headerlink" title="2.传递一个整数"></a>2.传递一个整数</h3><p>传递一个整数，这个整数代表的是距离1970-01-01 00:00:00的毫秒数（具体为什么是这个时间，小伙伴可以自己百度一下）。例如：传入参数为1000，将创建一个表示1970-01-01 00:00:01的日期对象。</p>
<p>我们举个例子，传递一个整数，看一下结果。</p>
<p>let d:Date = new Date(1000)<br>let da:Date = new Date(2000)<br>console.log(d)  //1970-01-01T00:00:01.000Z<br>console.log(da) //1970-01-01T00:00:02.000Z</p>
<h3 id="3-传递一个字符串"><a href="#3-传递一个字符串" class="headerlink" title="3.传递一个字符串"></a>3.传递一个字符串</h3><p>如果传递一个表示日期的字符串，就会生成相对应的日期对象。字符串的格式常用:yyyy/MM/dd hh:mm:ss，yyyy-MM-dd hh:mm:ss，yyyy-MM-ddThh:mm:ss等,具体可以参看下面的例子。</p>
<p>let d1:Date = new Date(‘2018/09/06 05:30:00’)<br>let d2:Date = new Date(‘2018-09-06 05:30:00’)<br>let d3:Date = new Date(‘2018-09-06T05:30:00’)<br>console.log(d1)<br>console.log(d2)<br>console.log(d3)<br>当然，他们打印出来的结果时完全相同的，所以在开发中你不用太过于纠结使用哪种方式进行声明。</p>
<h3 id="4-传递表示年月日时分秒的变量"><a href="#4-传递表示年月日时分秒的变量" class="headerlink" title="4.传递表示年月日时分秒的变量"></a>4.传递表示年月日时分秒的变量</h3><p>let d:Date = new Date(year,month,day,hours,minutes,seconds,ms);<br>year 表示年份，4位数字。<br>month表示月份，数值是0(1月)~11(12月)之间的整数。<br>day 表示日期。数值是1~31之间的整数。<br>hours 表示小时，数值是0-23之间的整数。<br>minutes 表示分钟数，数值是0~59之间的整数。<br>seconds 表示秒数，数值是0~59之间的整数。<br>ms 表示毫秒数，数值是0~999之间的整数。<br>至于Date类型的方法，跟JavaScript完全一样，</p>
<h2 id="第10节-引用类型-正则表达式"><a href="#第10节-引用类型-正则表达式" class="headerlink" title="第10节:引用类型-正则表达式"></a>第10节:引用类型-正则表达式</h2><h3 id="认识正则表达式"><a href="#认识正则表达式" class="headerlink" title="认识正则表达式"></a>认识正则表达式</h3><p>创建正则表达式和字符串犹如一对好基友（类似），创建正则表达式也提供了两种方法，一种是才采用new 关键字，另一种是采用字面量的方式。</p>
<h5 id="构造函数法"><a href="#构造函数法" class="headerlink" title="构造函数法"></a>构造函数法</h5><p>构造函数中可以传一个参数，也可以传递两个参数。一个是字符串描述，另一个是修饰符，比如g是全局修饰符，i是忽略大小写，m是多行模式。</p>
<p>举个例子：</p>
<p>let reg1:RegExp = new RegExp(“opq”)  //表示字符串规则里含有opq<br>console.log(reg1)<br>let reg2:RegExp = new RegExp(“opq”,’gi’)<br>console.log(reg2)<br>其实现在打印出来的就是字面量的赋值方法。我们可以在视频中看到输出的结果。</p>
<h5 id="字面量法"><a href="#字面量法" class="headerlink" title="字面量法"></a>字面量法</h5><p>其实构造函数的方法我个人用的是比较少的，我都会使用字面量法来声明正则表达式。</p>
<p>let reg3:RegExp = /opq/<br>let reg4:RegExp = /opq/gi</p>
<h3 id="RegExp中的常用方法"><a href="#RegExp中的常用方法" class="headerlink" title="RegExp中的常用方法"></a>RegExp中的常用方法</h3><p>RegExp对象包含两个方法：test( )和exec( ),功能基本相似，用于测试字符串匹配。</p>
<p>test(string) ：在字符串中查找是否存在指定的正则表达式并返回布尔值，如果存在则返回 true，不存在则返回 false。<br>exec(string) : 用于在字符串中查找指定正则表达式，如果 exec() 方法执行成功，则返回包含该查找字符串的相关信息数组。如果执行失败，则返回 null。<br>来看一个test的例子：</p>
<p>let reg1:RegExp =  /opq/i<br>let website:string = ‘opq.com’<br>let result:boolean = reg1.test(website)<br>console.log(result)    //true<br>这时候控制台打印出来的是true，那么我们再来看一下exec的使用方法。</p>
<p>let reg1:RegExp =  /opq/i<br>let website:string = ‘opq.com’<br>console.log(reg1.exec(website))<br>//[ ‘opq’, index: 0, input: ‘opq.com’ ]<br>输出的结果变为了[ ‘opq’, index: 0, input: ‘opq.com’ ]。</p>
<p>剩下的就是正则表达式的语法了，：<a href="http://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/regexp/regexp-tutorial.html</a></p>
<h2 id="第11节-面向对象编程-类的声明和使用"><a href="#第11节-面向对象编程-类的声明和使用" class="headerlink" title="第11节: 面向对象编程-类的声明和使用"></a>第11节: 面向对象编程-类的声明和使用</h2><p>TypeScript提供了强大的类的支持，作为一个程序员一定要学会类的使用，因为只有会了类才可以new出对象来，否者可能会单身一辈子哦（开个玩笑） 。类的出现可以让前端程序员抽象层次、增加维护性和复用性。当然这一系列的类的操作，我们都叫他面向对象编程。TypeScript就是一个基于类的面向对象编程语言。</p>
<h3 id="认识类与对象"><a href="#认识类与对象" class="headerlink" title="认识类与对象"></a>认识类与对象</h3><p>类是对象具体事务的一个抽象，对象是类的具体表现。<br>举个例子，比如说，有人给你介绍对象，会问你的要求。那么，你的要求是：身高165以上，体型偏瘦，长头发，大眼睛。从事正当稳定的工作，会做饭等等。这些要求就是对你心中理想伴侣的一个抽象，就是类。介绍人按照你的要求给你找的这些女生，就是类的实例，就是对象。</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>认识TypeScript基于类的面向对象编程，就需要从一个简单的类开始。</p>
<p>我们模拟一个小姐姐的类，小姐姐需要有年龄，有姓名，会说“小哥哥好”。</p>
<p>看下面的例子：</p>
<p>class XiaoJieJie{<br>    name:string;<br>    age:number;<br>    constructor(name:string,age:number){<br>        this.name = name<br>        this.age = age<br>    }<br>    say(){<br>        console.log(‘小哥哥好’)<br>    }<br>}<br>let jiejie:XiaoJieJie = new XiaoJieJie(‘哈喽’,18)<br>console.log(jiejie)<br>jiejie.say()<br>我们先用class关键字声明了一个类，并在里边声明了name和age属性。constructor为构造函数。构造函数的主要作用是给类中封装的属性进行赋值。</p>
<p>使用和定义类其实很简单，关键是理解类的思想。要有抽象逻辑的能力，这样才能复用和增强维护性。</p>
<h2 id="第12节-面向对象编程-修饰符"><a href="#第12节-面向对象编程-修饰符" class="headerlink" title="第12节: 面向对象编程-修饰符"></a>第12节: 面向对象编程-修饰符</h2><p>类中的修饰符是最常见的，TypeScript为我们准备了丰富的修饰符，小伙伴们可以和我一起学习一下修饰符。</p>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>TypeScript语言和Java还有C#很像（因为我只会这两个面向对象的语言），类中属性的访问可以用访问修饰符来进行限制。访问修饰符分为：public、protected、private。</p>
<p>public:公有修饰符，可以在类内或者类外使用public修饰的属性或者行为，默认修饰符。<br>protected:受保护的修饰符，可以本类和子类中使用protected修饰的属性和行为。<br>private : 私有修饰符，只可以在类内使用private修饰的属性和行为。<br>我们还是写一个小姐姐的类，但是我们使用一些访问修饰符来修饰。</p>
<p>详细讲解，请看视频。</p>
<p>class XiaoJieJie2{<br>    public sex:string<br>    protected name:string<br>    private age:number<br>    public constructor(sex:string,name:string,age:number){<br>        this.sex=sex<br>        this.name=name<br>        this.age=age<br>    }<br>    public sayHello(){<br>        console.log(‘小哥哥好’)<br>    }<br>    protected sayLove(){<br>        console.log(‘我爱你’)<br>    }<br>}<br>var jiejie2:XiaoJieJie2 = new XiaoJieJie2(‘女’,’热巴’,22)<br>console.log(jiejie2.sex)<br>console.log(jiejie2.name)   //报错<br>console.log(jiejie2.age)    //报错<br>jiejie2.sayHello()<br>jiejie2.sayLove()    //报错<br>你可以在写代码的时候，就会发现，编辑器已经给我们报错了。</p>
<h3 id="只读属性修饰符"><a href="#只读属性修饰符" class="headerlink" title="只读属性修饰符"></a>只读属性修饰符</h3><p>使用readonly修饰符将属性设置为只读，只读属性必须在生命时或者构造函数里被初始化（注意）。</p>
<p>我们声明一个man的抽象类，里边只有一个属性sex，并且是只读。</p>
<p>class Man{<br>    public readonly sex:string = ‘男’<br>}<br>var man:Man = new Man()<br>man.sex=’女’<br>在编辑器里你就会发现报错了，我们就不强行编译了。</p>
<h2 id="第13节-面向对象编程-继承和重写"><a href="#第13节-面向对象编程-继承和重写" class="headerlink" title="第13节: 面向对象编程-继承和重写"></a>第13节: 面向对象编程-继承和重写</h2><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>在使用TypeScript这门语言时，一个最重要基本功就是面向对象编程，那对类的扩展就变的格外重要，扩展经常使用的手段就是继承。</p>
<p>继承：允许我们创建一个类（子类），从已有的类（父类）上继承所有的属性和方法，子类可以新建父类中没有的属性和方法。<br>我们先来创建一个父类，这个父类完全抽象了你好啊的特点。</p>
<p>class opq{<br>    public name:string<br>    public age : number<br>    public skill: string<br>    constructor(name:string,age:number,skill:string){<br>        this.name = name<br>        this.age = age<br>        this.skill = skill<br>    }<br>    public interest(){<br>        console.log(‘找小姐姐’)<br>    }<br>}<br>let opqObj:opq = new opq(‘你好啊’,18,’web’)<br>opqObj.interest()<br>我作了一个我自己的抽象类，有姓名，有年龄，有技能，然后还有一个函数是兴趣。类创建好之后我们就进行了实例化。</p>
<p>现在你好啊要繁衍生息了，跟准备生个儿子（也就是我们说的子类）。那我的儿子一定要比我强啊，他不仅完全继承了我的基因，还增加了帅气的属性和赚钱的本领。</p>
<p>我们看看如何用程序实现。</p>
<p>class JsShuai extends opq{<br>    public xingxiang:string = ‘帅气’<br>    public zhuangQian(){<br>        console.log(‘一天赚了一个亿’)<br>    }<br>}<br>let shuai = new JsShuai(“技术帅”,5,’演讲’)<br>shuai.interest()<br>shuai.zhuangQian()<br>extends关键字就是继承的重点，它相当于我们扑倒女神，小蝌蚪从身体内迸发的一瞬间，所以我们一定要牢记这种感受…..不，是关键词.</p>
<p>但是有一点需要我们注意，TypeScript不支持多重继承。</p>
<h3 id="类方法的重写"><a href="#类方法的重写" class="headerlink" title="类方法的重写"></a>类方法的重写</h3><p>重写就是在子类中重写父类的方法。例如，我的儿子“技术帅”发现兴趣爱好是找小姐姐，完成不了“”一天赚一个亿“”的目标，它需要多个兴趣，开平台网站。这时候我们就用到了重写。看下面的列子代码：</p>
<p>class JsShuai extends opq{<br>    public xingxiang:string = ‘帅气’<br>    public interest(){<br>        super.interest()<br>        console.log(‘建立电商平台’)<br>    }<br>    public zhuangQian(){<br>        console.log(‘一天赚了一个亿’)<br>    }<br>}<br>先是继承了父类的方法，然后通过super关键字调用了父类的方法，实现了技能的增加。</p>
<h2 id="第14节-面向对象编程-接口"><a href="#第14节-面向对象编程-接口" class="headerlink" title="第14节:面向对象编程-接口"></a>第14节:面向对象编程-接口</h2><p>在通常情况下，接口是用来定义一些规范，使用这些接口，就必须实现按照接口中的规范来走。</p>
<p>在面向对象的语言中，术语interface经常被用来定义一个不包含数据和逻辑代码但是用来签名定义了行为的抽象类型。</p>
<h3 id="认识接口"><a href="#认识接口" class="headerlink" title="认识接口"></a>认识接口</h3><p>定义接口的关键字是interface。我们现在就来定义一个接口，这个接口是用来规范丈夫的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Husband &#123;</span><br><span class="line">    sex:string</span><br><span class="line">    interest:string</span><br><span class="line">&#125;</span><br><span class="line">let myhusband:Husband =&#123; sex:&apos;男&apos;,interest:&apos;看书、作家务&apos;&#125;</span><br><span class="line">console.log(myhusband)</span><br></pre></td></tr></table></figure></p>
<p>我们通过接口，定义了一个找老公的接口，并且给他了两个必选项：性别和兴趣爱好.</p>
<h3 id="可选参数的接口"><a href="#可选参数的接口" class="headerlink" title="可选参数的接口"></a>可选参数的接口</h3><p>对老公的标准如果我们有一些可选项，这些并不是都需要显示出来的，在有些情况下，我们只需要传入部分参数。我们可以使用问好的形式来设置可选参数。</p>
<p>比如现在我们还希望老公的标准，有一条是给我“买包包”，但是这个是隐喻的，不是直接显示出来的。我们修改我们的接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Husband &#123;</span><br><span class="line">    sex:string</span><br><span class="line">    interest:string</span><br><span class="line">    maiBaoBao?:Boolean</span><br><span class="line">&#125;</span><br><span class="line">let myhusband:Husband =&#123; sex:&apos;男&apos;,interest:&apos;看书、作家务&apos;,maiBaoBao:true&#125;</span><br><span class="line">console.log(myhusband)</span><br></pre></td></tr></table></figure></p>
<p>上面的代码maiBaoBao选项就是可选的，可以写也可以不写。那撇开程序不谈，你写成为丈夫的几率肯定要大一些。</p>
<h3 id="规范函数类型接口"><a href="#规范函数类型接口" class="headerlink" title="规范函数类型接口"></a>规范函数类型接口</h3><p>我们还可以使用接口来规范函数类型的接口，比如现在要找老公这件事，我们规定有一些资源，然后我们需要哪些资源，在函数中进行匹配，最后返回是否匹配成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface  SearchMan&#123;</span><br><span class="line">    (source:string,subString:string):boolean</span><br><span class="line">&#125;</span><br><span class="line">let mySearch:SearchMan</span><br><span class="line">mySearch = function(source:string,subString:string):boolean&#123;</span><br><span class="line">    let flag =source.search(subString)</span><br><span class="line">    return (flag != -1)</span><br><span class="line">&#125; </span><br><span class="line">console.log(mySearch(&apos;高、富、帅、德&apos;,&apos;胖&apos;)) //false</span><br></pre></td></tr></table></figure></p>
<h2 id="第15节-面向对象编程-命名空间"><a href="#第15节-面向对象编程-命名空间" class="headerlink" title="第15节:面向对象编程-命名空间"></a>第15节:面向对象编程-命名空间</h2><p>在制作大型应用的时候，为了让程序更加有层次感和变量之间不互相干扰，我们可以使用命名空间来构建程序。举个小例子：比如“德华”这件事，帅哥也有叫德华的，二师兄也有叫德华的。那我们要如何区分那。这对于女孩子选老公来说非常重要啊。</p>
<h3 id="命名空间的使用"><a href="#命名空间的使用" class="headerlink" title="命名空间的使用"></a>命名空间的使用</h3><p>当然命名空间就是解决这个问题的，命名空间，又称内部模块，被用于组织有些具有内在联系的特性和对象。我们来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">namespace shuaiGe&#123;</span><br><span class="line">    export class Dehua&#123;</span><br><span class="line">        public name:string = &apos;刘德华&apos;</span><br><span class="line">        talk()&#123;</span><br><span class="line">            console.log(&apos;我是帅哥刘德华&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">namespace bajie&#123;</span><br><span class="line">    export class Dehua&#123;</span><br><span class="line">        public name:string = &apos;马德华&apos;</span><br><span class="line">        talk()&#123;</span><br><span class="line">            console.log(&apos;我是二师兄马德华&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let dehua1:shuaiGe.Dehua   = new shuaiGe.Dehua()</span><br><span class="line">let dehua2:shuaiGe.Dehua   = new bajie.Dehua()</span><br><span class="line">dehua1.talk()</span><br></pre></td></tr></table></figure></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src>
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title="0" data-url="http://link.hhtjim.com/163/5146554.mp3"></li>
                    
                        <li title="1" data-url="http://link.hhtjim.com/qq/001faIUs4M2zna.mp3"></li>
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci data-cs data-r data-o data-a data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>